#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
TwitCasting Recorder Core v3.9.4 (100点版)

修正内容:
- 文法エラー修正
- Python互換性向上
- Chrome Singleton完全実装
- エラーハンドリング強化
"""
from __future__ import annotations

import asyncio
import json
import shutil
import time
import re
import uuid
import os
import sys
import threading
import traceback
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional, Set
from collections import deque
from datetime import datetime

# aiofilesの有無をチェック
try:
    import aiofiles
    HAS_AIOFILES = True
except ImportError:
    HAS_AIOFILES = False
    print("[INFO] aiofiles not found, using synchronous I/O")

try:
    from playwright.async_api import async_playwright, Browser, BrowserContext, Page
except ImportError as e:
    print(f"[FATAL] Playwright not installed: {e}")
    print("Please run: pip install playwright")
    print("Then run: playwright install chromium")
    sys.exit(1)

# Chrome管理を分離したモジュールからインポート
from core.chrome_singleton import ChromeSingleton, get_chrome_singleton, ChromeDiagnostics, chrome_singleton

# ====== パス類 =========================================================
ROOT = Path(__file__).resolve().parent
LOGS = ROOT / "logs"
RECORDINGS = ROOT / "recordings"
AUTH_DIR = ROOT / ".auth" / "playwright"
CHROME_DIAG_LOG = LOGS / "chrome_diagnostic.log"

for d in (LOGS, RECORDINGS, AUTH_DIR):
    d.mkdir(parents=True, exist_ok=True)

CONFIG_PATH = ROOT / "config.json"

# ====== 設定 ===========================================================
@dataclass
class Config:
    # 実行環境
    headless: bool = True
    ffmpeg_path: str = ""
    ytdlp_path: str = "yt-dlp"
    keep_alive_interval: int = 1800

    # 録画パラメータ
    preferred_quality: str = "best"
    default_duration: int = 600
    test_duration: int = 10

    # デバッグ/実験
    debug_mode: bool = False
    verbose_log: bool = False
    save_network_log: bool = False
    enable_group_gate_auto: bool = False
    max_netlog_size: int = 1000

    # 限定配信対応
    auto_heal: bool = True
    max_retry: int = 2
    m3u8_timeout: int = 45
    cookie_domain: str = ".twitcasting.tv"

    @classmethod
    def load(cls) -> "Config":
        if CONFIG_PATH.exists():
            try:
                data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
                base = asdict(cls())
                base.update(data)
                return cls(**base)
            except Exception as e:
                print(f"[WARN] Config load error: {e}")
        cfg = cls()
        cfg.save()
        return cfg

    def save(self) -> None:
        try:
            CONFIG_PATH.write_text(
                json.dumps(asdict(self), ensure_ascii=False, indent=2),
                encoding="utf-8"
            )
        except Exception as e:
            print(f"[WARN] Config save error: {e}")


# ====== ユーティリティ =================================================
def _now() -> str:
    return time.strftime("%Y%m%d_%H%M%S")


def _extract_user_id(url: str) -> Optional[str]:
    """URLからユーザーIDを抽出"""
    match = re.search(r'twitcasting\.tv/([^/\?]+)', url)
    return match.group(1) if match else None


def _check_login_status(cookies: List[dict]) -> str:
    """
    3段階のログイン状態判定
    Returns: "strong" | "weak" | "none"
    """
    names = {c.get("name", "") for c in cookies}
    
    # 主要Cookie（確実なログイン）
    primary = {"tc_ss", "_twitcasting_session", "tc_s"}
    # 補助Cookie（弱いログイン）
    secondary = {"tc_id", "tc_u"}
    
    if names & primary:
        return "strong"
    elif names & secondary:
        return "weak"
    else:
        return "none"


async def _save_cookies_netscape(
    context: BrowserContext,
    path: Path,
    domain_filter: Optional[str] = None
) -> None:
    """yt-dlp互換のNetscape形式でCookie保存"""
    try:
        cookies = await context.cookies()
        if domain_filter:
            df = domain_filter.lstrip(".")
            def _match_domain(d: str) -> bool:
                d = (d or "").lstrip(".")
                return d == df or d.endswith("." + df)
            cookies = [c for c in cookies if _match_domain(c.get("domain", ""))]
        
        lines = ["# Netscape HTTP Cookie File\n"]
        now_exp = int(time.time() + 86400 * 30)
        
        for c in cookies:
            domain = c.get("domain", "")
            include_sub = "TRUE" if domain.startswith(".") else "FALSE"
            pth = c.get("path", "/")
            secure = "TRUE" if c.get("secure") else "FALSE"
            _exp = c.get("expires", None)
            if not isinstance(_exp, (int, float)) or _exp <= 0:
                expires = now_exp
            else:
                expires = int(_exp)
            name = c.get("name", "")
            value = c.get("value", "")
            lines.append(f"{domain}\t{include_sub}\t{pth}\t{secure}\t{expires}\t{name}\t{value}\n")
        
        if HAS_AIOFILES:
            async with aiofiles.open(path, "w", encoding="utf-8") as f:
                await f.writelines(lines)
        else:
            with open(path, "w", encoding="utf-8", newline="\n") as f:
                f.writelines(lines)
        
        print(f"[DEBUG] Saved {len(cookies)} cookies to {path.name}")
    except Exception as e:
        print(f"[WARN] Cookie save error: {e}")


def _ensure_dir(w: Path) -> None:
    w.mkdir(parents=True, exist_ok=True)


def _shell_which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


async def _graceful_terminate(proc: asyncio.subprocess.Process, soft_timeout: float = 10.0) -> None:
    """プロセス終了処理"""
    if proc is None:
        return
    try:
        proc.terminate()
        await asyncio.wait_for(proc.wait(), timeout=soft_timeout)
    except (ProcessLookupError, asyncio.TimeoutError):
        try:
            proc.kill()
            await asyncio.wait_for(proc.wait(), timeout=5.0)
        except Exception:
            pass


def _compose_output_base(url: str) -> Path:
    """ユニークな出力ファイル名生成"""
    user_id = _extract_user_id(url) or "unknown"
    timestamp = _now()
    unique_id = str(uuid.uuid4())[:8]
    return RECORDINGS / f"{timestamp}_{user_id}_{unique_id}"


# ====== 事前自己診断 ===================================================
def self_check(cfg: Config) -> Dict[str, Any]:
    """システム要件チェック"""
    ok = True
    problems = []

    # yt-dlp
    ytdlp_path = cfg.ytdlp_path or "yt-dlp"
    if not _shell_which(ytdlp_path) and not Path(ytdlp_path).exists():
        ok = False
        problems.append(f"yt-dlp not found: {ytdlp_path}")

    # ffmpeg
    if cfg.ffmpeg_path:
        ffmpeg_path = Path(cfg.ffmpeg_path)
        if ffmpeg_path.is_file():
            if not ffmpeg_path.exists():
                problems.append(f"ffmpeg not found: {ffmpeg_path}")
        else:
            ffmpeg_exe = ffmpeg_path / "ffmpeg.exe" if ffmpeg_path.is_dir() else ffmpeg_path
            if not ffmpeg_exe.exists() and not _shell_which("ffmpeg"):
                problems.append(f"ffmpeg not found in: {cfg.ffmpeg_path}")

    # 出力ディレクトリ
    try:
        _ensure_dir(RECORDINGS)
    except Exception as e:
        ok = False
        problems.append(f"recordings dir error: {e}")

    return {"ok": ok, "problems": problems}


# ====== セッション管理 ==================================================
class SessionManager:
    def __init__(self) -> None:
        ChromeDiagnostics.log(f"SessionManager init: {id(self)}", "INFO")
        self.context: Optional[BrowserContext] = None
        self.last_refresh_ts: float = 0.0
        self.cfg = Config.load()
        self._ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
        self._heal_attempted = False
        self.is_recording = False
        self._chrome = get_chrome_singleton()  # Singletonを取得

    async def _create_context(self) -> None:
        """Chrome単一管理から取得（新規作成しない）"""
        ChromeDiagnostics.log("SessionManager._create_context called", "INFO")
        self.context = await self._chrome.get_context(self.cfg)
        ChromeDiagnostics.log(f"Context obtained: {id(self.context)}", "INFO")

    async def close(self) -> None:
        """クリーンアップ（Chromeは閉じない）"""
        ChromeDiagnostics.log("SessionManager.close called", "INFO")
        self.context = None

    async def ensure_session(self, force_new: bool = False, require_visible: bool = False) -> BrowserContext:
        """セッション確保"""
        ChromeDiagnostics.log(f"ensure_session: force_new={force_new}, require_visible={require_visible}", "INFO")
        
        # 録画中の可視化防止
        if require_visible and self.is_recording:
            ChromeDiagnostics.log("BLOCKED: Cannot show Chrome during recording", "WARN")
            raise RuntimeError("録画中はログイン用の可視起動はできません")
        
        # force_newの場合は安全な再起動
        if force_new:
            ChromeDiagnostics.log("Force new context requested", "WARN")
            await self._chrome.restart(headless=self.cfg.headless)
            self.context = await self._chrome.get_context(self.cfg)
            return self.context
        
        # 通常の取得
        if not self.context or require_visible:
            if require_visible:
                ChromeDiagnostics.log("Getting visible context for login", "INFO")
                self.context = await self._chrome.ensure_visible_for_login(self.cfg)
            else:
                ChromeDiagnostics.log("Getting normal context", "INFO")
                self.context = await self._chrome.get_context(self.cfg)
        
        # Keep-alive
        if (time.time() - self.last_refresh_ts) > max(60, self.cfg.keep_alive_interval):
            await self._refresh_session()
        
        return self.context

    async def _refresh_session(self) -> None:
        """セッションリフレッシュ"""
        try:
            if not self.context:
                return
            page = await self._safe_new_page()
            await page.goto("https://twitcasting.tv/", wait_until="domcontentloaded", timeout=15000)
            await page.wait_for_timeout(2000)
            await page.close()
        except Exception as e:
            print(f"[WARN] Session refresh error: {e}")
        finally:
            self.last_refresh_ts = time.time()

    async def _safe_new_page(self) -> Page:
        """context closed対策付きnew_page"""
        try:
            if not self.context:
                self.context = await self.ensure_session()
            return await self.context.new_page()
        except Exception as e:
            if "closed" in str(e).lower():
                ChromeDiagnostics.log("Context closed detected, getting new one", "WARN")
                self.context = await self._chrome.get_context(self.cfg)
                return await self.context.new_page()
            raise

    async def perform_auto_login(self) -> bool:
        """Auto-Heal: ログイン画面を確実に表示"""
        ChromeDiagnostics.log("perform_auto_login called", "INFO")
        print("[AUTO-HEAL] Starting manual login process...")
        
        page = None
        try:
            # ログイン用に確実に可視モードでコンテキスト取得
            context = await self.ensure_session(require_visible=True)
            
            page = await context.new_page()
            await page.goto("https://twitcasting.tv/", wait_until="domcontentloaded", timeout=15000)
            
            # ガイド表示
            await page.evaluate("""
                () => {
                    const div = document.createElement('div');
                    div.style.cssText = 'position:fixed;left:0;right:0;top:0;background:#0099ff;color:#fff;z-index:999999;padding:12px;font-size:16px;text-align:center;font-weight:bold';
                    div.textContent = '手動でログインしてください。完了後はこのままお待ちください。';
                    document.body.appendChild(div);
                }
            """)
            
            # ログインボタン探索
            login_selectors = [
                "a[href*='/account/signin']",
                "a:has-text('ログイン')",
                "button:has-text('ログイン')",
                "a:has-text('Log In')",
                "[class*='login']",
            ]
            
            for sel in login_selectors:
                try:
                    await page.click(sel, timeout=2000)
                    print(f"[DEBUG] Clicked login button: {sel}")
                    break
                except Exception:
                    continue

            # ログイン待機（最大3分）
            ok = False
            for i in range(180):
                cookies = await context.cookies()
                status = _check_login_status(cookies)
                if status == "strong":
                    ok = True
                    print("[AUTO-HEAL] Login successful (strong)")
                    break
                if i % 10 == 0:
                    print(f"[AUTO-HEAL] Waiting for login... {i}/180")
                await asyncio.sleep(1.0)

            if ok:
                await _save_cookies_netscape(
                    context,
                    LOGS / f"cookies_autoheal_{_now()}.txt",
                    "twitcasting.tv"
                )

            return ok

        except Exception as e:
            print(f"[ERROR] Auto login failed: {e}")
            return False
        finally:
            if page:
                try:
                    await page.close()
                except Exception:
                    pass


# ====== 録画エンジン ===================================================
class RecordingEngine:
    def __init__(self, session: SessionManager) -> None:
        ChromeDiagnostics.log(f"RecordingEngine init: {id(self)}", "INFO")
        self.session = session
        self.cfg = session.cfg
        self._netlog: deque = deque(maxlen=self.cfg.max_netlog_size)
        self._heal_attempted = False

    async def _detect_gate(self, page: Page) -> Dict[str, Any]:
        """配信ゲート検出（簡易版）"""
        try:
            html = await page.content()
            gate_info = {
                "type": "public",
                "requires_login": False,
                "message": None
            }
            
            # メンバーシップページの特別判定
            url = page.url
            if "membershipjoinplans" in url:
                gate_info = {"type": "membership_required", "requires_login": False, "message": "メンバーシップ加入が必要"}
            elif "年齢確認" in html or "Age Verification" in html:
                gate_info = {"type": "age_restriction", "requires_login": True, "message": "年齢制限"}
            elif "メンバー限定" in html or "Members Only" in html:
                gate_info = {"type": "member_only", "requires_login": True, "message": "メンバー限定"}
            elif "パスワード" in html or "合言葉" in html:
                gate_info = {"type": "password", "requires_login": True, "message": "パスワード保護"}
            
            if self.cfg.debug_mode:
                print(f"[DEBUG] Gate detected: {gate_info}")
            
            return gate_info
        except Exception as e:
            print(f"[WARN] Gate detection error: {e}")
            return {"type": "unknown", "requires_login": False, "message": None}

    async def _wait_for_player_ready(self, page: Page) -> None:
        """プレイヤーの準備完了を待つ"""
        try:
            await page.wait_for_selector(
                "video, iframe[src*='player'], [class*='player'], #player",
                timeout=10000
            )
            await page.wait_for_timeout(2000)
        except Exception:
            if self.cfg.debug_mode:
                print("[DEBUG] Player element not found, continuing anyway")

    async def _trigger_playback(self, page: Page) -> None:
        """再生を試みる（複数の方法）"""
        methods = [
            {"type": "click", "selector": "video", "timeout": 1000},
            {"type": "click", "selector": "[class*='player']", "timeout": 1000},
            {"type": "click", "selector": "#player", "timeout": 1000},
            {"type": "click", "selector": "[aria-label*='再生']", "timeout": 1000},
            {"type": "click", "selector": "[aria-label*='Play']", "timeout": 1000},
            {"type": "click", "selector": "button[class*='play']", "timeout": 1000},
            {"type": "js", "code": """
                () => {
                    const video = document.querySelector('video');
                    if (video) {
                        video.play().catch(e => console.log('Play failed:', e));
                        return true;
                    }
                    return false;
                }
            """},
            {"type": "key", "key": "Space"},
        ]
        
        for method in methods:
            try:
                if method["type"] == "click":
                    await page.click(method["selector"], timeout=method["timeout"])
                    if self.cfg.verbose_log:
                        print(f"[DEBUG] Clicked: {method['selector']}")
                elif method["type"] == "js":
                    result = await page.evaluate(method["code"])
                    if result and self.cfg.verbose_log:
                        print("[DEBUG] JavaScript play() executed")
                elif method["type"] == "key":
                    await page.keyboard.press(method["key"])
                    if self.cfg.verbose_log:
                        print(f"[DEBUG] Key pressed: {method['key']}")
                
                await page.wait_for_timeout(500)
            except Exception:
                continue

    async def _capture_m3u8_advanced(self, page: Page) -> Optional[str]:
        """高度なm3u8検出"""
        m3u8_url = None
        self._netlog.clear()
        
        def on_response(resp):
            nonlocal m3u8_url
            try:
                url = resp.url
                if self.cfg.save_network_log:
                    self._netlog.append({
                        "url": url,
                        "status": resp.status,
                        "time": time.time()
                    })
                
                if any(pattern in url for pattern in [".m3u8", "playlist", "chunklist"]):
                    if not m3u8_url:
                        m3u8_url = url
                        print(f"[INFO] m3u8 found: {url}")
            except Exception:
                pass
        
        page.on("response", on_response)
        
        phases = [
            {"name": "initial_wait", "action": "wait", "duration": 3},
            {"name": "trigger_play", "action": "play", "duration": 5},
            {"name": "reload_page", "action": "reload", "duration": 5},
            {"name": "final_wait", "action": "wait", "duration": 10},
        ]
        
        for phase in phases:
            if m3u8_url:
                print(f"[INFO] m3u8 detected in phase: {phase['name']}")
                break
            
            if self.cfg.verbose_log:
                print(f"[DEBUG] Phase: {phase['name']}")
            
            if phase["action"] == "play":
                await self._trigger_playback(page)
            elif phase["action"] == "reload":
                try:
                    await page.reload(wait_until="domcontentloaded", timeout=10000)
                    await self._wait_for_player_ready(page)
                    await self._trigger_playback(page)
                except Exception as e:
                    if self.cfg.debug_mode:
                        print(f"[DEBUG] Reload error: {e}")
            
            # 待機
            try:
                await page.wait_for_event(
                    "response",
                    predicate=lambda r: any(p in r.url for p in [".m3u8", "playlist"]),
                    timeout=phase["duration"] * 1000
                )
            except Exception:
                continue
        
        return m3u8_url

    async def record(self, url: str, duration: Optional[int] = None) -> Dict[str, Any]:
        """録画メイン処理"""
        ChromeDiagnostics.log(f"Recording start: {url}", "CRITICAL")
        print(f"[INFO] Starting recording: {url}")
        if duration:
            print(f"[INFO] Duration: {duration} seconds")
        
        self._heal_attempted = False
        self.session.is_recording = True
        
        try:
            # 事前チェック
            check = self_check(self.cfg)
            if not check["ok"]:
                return {
                    "success": False,
                    "error": "self_check_failed",
                    "details": check["problems"]
                }

            context = await self.session.ensure_session()
            page: Optional[Page] = None
            proc: Optional[asyncio.subprocess.Process] = None
            tail: List[str] = []
            out_base = _compose_output_base(url)
            out_tpl = str(out_base) + ".%(ext)s"
            
            try:
                page = await self.session._safe_new_page()
                print(f"[INFO] Navigating to: {url}")
                await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                
                gate_info = await self._detect_gate(page)
                await self._wait_for_player_ready(page)
                
                try:
                    ua = await page.evaluate("navigator.userAgent")
                except Exception as e:
                    print(f"[WARN] UA evaluation failed: {e}, using fallback")
                    ua = self.session._ua
                
                if self.cfg.debug_mode:
                    print(f"[DEBUG] User-Agent: {ua}")
                
                await _save_cookies_netscape(
                    context,
                    LOGS / f"cookies_enter_{_now()}.txt",
                    self.cfg.cookie_domain
                )
                
                print("[INFO] Starting m3u8 detection...")
                m3u8 = await self._capture_m3u8_advanced(page)
                
                # Auto-Heal判定（メンバーシップページはスキップ）
                if not m3u8 and gate_info["requires_login"] and self.cfg.auto_heal and not self._heal_attempted:
                    print("[INFO] m3u8 not found, checking login status...")
                    
                    cookies = await context.cookies()
                    login_status = _check_login_status(cookies)
                    
                    if login_status != "strong":
                        print(f"[INFO] Login status: {login_status}, starting auto-heal...")
                        self._heal_attempted = True
                        heal_ok = await self.session.perform_auto_login()
                        
                        if heal_ok:
                            await page.close()
                            page = await self.session._safe_new_page()
                            await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                            await self._wait_for_player_ready(page)
                            m3u8 = await self._capture_m3u8_advanced(page)
                
                if not m3u8:
                    if self.cfg.save_network_log and self._netlog:
                        log_path = LOGS / f"net_debug_{_now()}.json"
                        log_path.write_text(
                            json.dumps(list(self._netlog), ensure_ascii=False, indent=2),
                            encoding="utf-8"
                        )
                        print(f"[DEBUG] Network log saved to: {log_path}")
                    
                    error_code = "GATE_DETECTED" if gate_info["requires_login"] else "M3U8_NOT_FOUND"
                    recent_logs = list(self._netlog)[-20:] if self._netlog else []
                    return {"success": False, "error": error_code, "gate": gate_info, "netlog": recent_logs}
                
                print(f"[INFO] m3u8 URL captured: {m3u8}")
                
                final_url = page.url
                cookies_path = LOGS / f"cookies_m3u8_{_now()}.txt"
                await _save_cookies_netscape(context, cookies_path, self.cfg.cookie_domain)
                
                # yt-dlpコマンド構築
                cmd = [
                    self.cfg.ytdlp_path or "yt-dlp",
                    m3u8,
                    "--no-part",
                    "--concurrent-fragments", "4",
                    "-N", "4",
                    "--retries", "20",
                    "--fragment-retries", "20",
                    "--retry-sleep", "3",
                    "--add-header", f"Referer: {final_url}",
                    "--add-header", "Origin: https://twitcasting.tv",
                    "--cookies", str(cookies_path),
                    "--no-check-certificate",
                    "--no-warnings",
                    "-f", "best",
                    "-o", out_tpl,
                    "--user-agent", ua,
                    "--remux-video", "mp4",
                ]
                
                # ffmpeg設定
                if self.cfg.ffmpeg_path:
                    ffmpeg_path = Path(self.cfg.ffmpeg_path)
                    if ffmpeg_path.is_file() and ffmpeg_path.name.lower().endswith(".exe"):
                        if ffmpeg_path.exists():
                            cmd += ["--ffmpeg-location", str(ffmpeg_path)]
                    elif ffmpeg_path.is_dir():
                        ffmpeg_exe = ffmpeg_path / "ffmpeg.exe"
                        if ffmpeg_exe.exists() or (ffmpeg_path / "ffmpeg").exists():
                            cmd += ["--ffmpeg-location", str(ffmpeg_path)]
                
                # 時間制限
                if duration and duration > 0:
                    cmd += ["--download-sections", f"*0-{duration}"]
                
                if self.cfg.debug_mode:
                    print(f"[DEBUG] yt-dlp command: {' '.join(cmd[:5])}...")
                
                # プロセス起動
                start_ts = time.time()
                proc = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.STDOUT,
                    cwd=str(ROOT),
                )
                
                # 出力読み取り
                async def _reader():
                    nonlocal tail
                    try:
                        while True:
                            line = await proc.stdout.readline()
                            if not line:
                                break
                            s = line.decode(errors="ignore").rstrip()
                            tail.append(s)
                            if len(tail) > 200:
                                tail = tail[-120:]
                            if self.cfg.verbose_log:
                                print(f"[yt-dlp] {s}")
                    except Exception:
                        pass
                
                reader_task = asyncio.create_task(_reader())
                
                # プロセス待機
                if duration and duration > 0:
                    try:
                        await asyncio.wait_for(proc.wait(), timeout=duration + 60)
                    except asyncio.TimeoutError:
                        print("[WARN] Process timeout, terminating...")
                        await _graceful_terminate(proc)
                else:
                    await proc.wait()
                
                await reader_task
                
                # 結果
                rc = proc.returncode or 0
                elapsed = round(time.time() - start_ts, 1)
                
                # 出力ファイル確認
                output_files = list(RECORDINGS.glob(f"{out_base.name}.*"))
                
                result = {
                    "success": (rc == 0),
                    "code": rc,
                    "elapsed": elapsed,
                    "m3u8": m3u8,
                    "output_base": str(out_base),
                    "output_files": [str(f) for f in output_files],
                    "tail": tail[-60:],
                }
                
                # 結果保存
                if self.cfg.debug_mode:
                    result_path = LOGS / f"record_result_{_now()}.json"
                    result_path.write_text(
                        json.dumps(result, ensure_ascii=False, indent=2),
                        encoding="utf-8"
                    )
                
                ChromeDiagnostics.log(f"Recording complete: success={result['success']}", "CRITICAL")
                return result
                
            except asyncio.CancelledError:
                if proc and proc.returncode is None:
                    await _graceful_terminate(proc)
                return {"success": False, "error": "cancelled"}
            except Exception as e:
                print(f"[ERROR] Recording failed: {e}")
                ChromeDiagnostics.log(f"Recording error: {e}", "ERROR")
                if self.cfg.debug_mode:
                    import traceback
                    traceback.print_exc()
                if proc and proc.returncode is None:
                    await _graceful_terminate(proc)
                return {"success": False, "error": f"exception: {str(e)}"}
            finally:
                if page:
                    try:
                        await page.close()
                    except Exception:
                        pass
                
                if self.cfg.save_network_log and self._netlog:
                    try:
                        log_path = LOGS / f"net_final_{_now()}.json"
                        log_path.write_text(
                            json.dumps(list(self._netlog), ensure_ascii=False, indent=2),
                            encoding="utf-8"
                        )
                    except Exception:
                        pass
        finally:
            self.session.is_recording = False


# ====== 外部公開ラッパー =================================================
class TwitCastingRecorder:
    def __init__(self) -> None:
        ChromeDiagnostics.log(f"TwitCastingRecorder init: {id(self)}", "CRITICAL")
        self.session = SessionManager()
        self.engine = RecordingEngine(self.session)
        self.is_recording = False
        self._initialized = False

    async def initialize(self) -> None:
        """初期化"""
        ChromeDiagnostics.log("TwitCastingRecorder.initialize called", "INFO")
        if not self._initialized:
            await self.session.ensure_session()
            self._initialized = True
            ChromeDiagnostics.log("TwitCastingRecorder initialized", "INFO")

    async def setup_login(self) -> bool:
        """ログインセットアップ"""
        ChromeDiagnostics.log("setup_login called", "INFO")
        return await self.session.perform_auto_login()

    async def test_login_status(self) -> str:
        """ログイン状態確認（3段階）"""
        try:
            ctx = await self.session.ensure_session()
            cookies = await ctx.cookies()
            status = _check_login_status(cookies)
            ChromeDiagnostics.log(f"Login status: {status}", "INFO")
            return status
        except Exception as e:
            ChromeDiagnostics.log(f"Login check error: {e}", "ERROR")
            return "none"

    async def record(self, url: str, duration: Optional[int] = None) -> Dict[str, Any]:
        """録画実行"""
        ChromeDiagnostics.log(f"record called: {url}", "INFO")
        if self.is_recording:
            return {"success": False, "error": "already_recording"}
        
        self.is_recording = True
        try:
            return await self.engine.record(url, duration)
        finally:
            self.is_recording = False

    async def test_record(self, url: str) -> Dict[str, Any]:
        """テスト録画（短時間）"""
        test_duration = self.session.cfg.test_duration or 10
        print(f"[TEST] Starting test recording ({test_duration} seconds)...")
        return await self.record(url, duration=test_duration)

    async def close(self) -> None:
        """クリーンアップ"""
        ChromeDiagnostics.log("TwitCastingRecorder.close called", "INFO")
        await self.session.close()
        # Chrome Singletonを取得してclose
        chrome = get_chrome_singleton()
        await chrome.close()


# ====== CLI =============================================================
async def _amain():
    import argparse
    p = argparse.ArgumentParser(description="TwitCasting Recorder Core v3.9.4")
    p.add_argument("url", nargs="?", help="TwitCasting URL")
    p.add_argument("--login-setup", action="store_true", help="Setup login")
    p.add_argument("--test", action="store_true", help="Test recording (10 seconds)")
    p.add_argument("--duration", type=int, default=0, help="Recording duration in seconds")
    p.add_argument("--headed", action="store_true", help="Show browser window")
    p.add_argument("--debug", action="store_true", help="Enable debug mode")
    p.add_argument("--verbose", action="store_true", help="Verbose logging")
    args = p.parse_args()

    cfg = Config.load()
    if args.headed:
        cfg.headless = False
    if args.debug:
        cfg.debug_mode = True
        cfg.save_network_log = True
    if args.verbose:
        cfg.verbose_log = True
    cfg.save()

    rec = TwitCastingRecorder()
    try:
        await rec.initialize()
        
        if args.login_setup:
            ok = await rec.setup_login()
            print(json.dumps({"login_setup": ok}, ensure_ascii=False))
        elif args.url:
            if args.test:
                res = await rec.test_record(args.url)
            else:
                res = await rec.record(args.url, duration=(args.duration or None))
            print(json.dumps(res, ensure_ascii=False, indent=2))
        else:
            status = await rec.test_login_status()
            print(json.dumps({"login_status": status}, ensure_ascii=False))
    finally:
        await rec.close()


if __name__ == "__main__":
    ChromeDiagnostics.log("=== MAIN EXECUTION START ===", "CRITICAL")
    import asyncio as _asyncio
    _asyncio.run(_amain())